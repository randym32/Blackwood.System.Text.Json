{
  "api/Blackwood.CasePreservingString.html": {
    "href": "api/Blackwood.CasePreservingString.html",
    "title": "Struct CasePreservingString | Blackwood.System.Text.Json",
    "summary": "Struct CasePreservingString Namespace Blackwood Assembly Blackwood.System.Text.Json.dll This represents a string that preserves its original case for display purposes but allows for case-insensitive comparisons. It provides methods to convert a string to this struct, compare two instances in a case-insensitive manner, and generate a hash code based on the uppercase version of the string. [JsonConverter(typeof(CasePreservingStringConverter))] public readonly struct CasePreservingString Remarks Creates a CasePreservingString instance. Constructors CasePreservingString(string) This represents a string that preserves its original case for display purposes but allows for case-insensitive comparisons. It provides methods to convert a string to this struct, compare two instances in a case-insensitive manner, and generate a hash code based on the uppercase version of the string. public CasePreservingString(string text) Parameters text string The text string. Remarks Creates a CasePreservingString instance. Fields text The string. public readonly string text Field Value string Methods Equals(CasePreservingString) Comparese the string in a caseless fashion. public bool Equals(CasePreservingString b) Parameters b CasePreservingString A string to compare against Returns bool True if the strings are equal, false otherwise Equals(object?) Compares this CasePreservingString with another object in a case-insensitive manner. public override bool Equals(object? obj) Parameters obj object The object to compare against Returns bool True if the objects are equal, false otherwise GetHashCode() The hash of the caseless string (all uppercase). public override int GetHashCode() Returns int The hash value ToString() Provides the string with the original case. public override string ToString() Returns string The string with the original case. Operators implicit operator string(CasePreservingString) Convert a case-preserving string back to a regular string. public static implicit operator string(CasePreservingString @string) Parameters string CasePreservingString The case-preserving string to convert Returns string implicit operator CasePreservingString(string) Convert a string to one that uses case-less matching. public static implicit operator CasePreservingString(string @string) Parameters string string The string to convert Returns CasePreservingString"
  },
  "api/Blackwood.CasePreservingStringConverter.html": {
    "href": "api/Blackwood.CasePreservingStringConverter.html",
    "title": "Class CasePreservingStringConverter | Blackwood.System.Text.Json",
    "summary": "Class CasePreservingStringConverter Namespace Blackwood Assembly Blackwood.System.Text.Json.dll Custom JSON converter for CasePreservingString serialization and deserialization. Supports both regular serialization and dictionary key serialization. public class CasePreservingStringConverter : JsonConverter<CasePreservingString> Inheritance object JsonConverter JsonConverter<CasePreservingString> CasePreservingStringConverter Inherited Members JsonConverter<CasePreservingString>.CanConvert(Type) JsonConverter<CasePreservingString>.HandleNull JsonConverter<CasePreservingString>.Type Methods Read(ref Utf8JsonReader, Type, JsonSerializerOptions) Reads a CasePreservingString from JSON. public override CasePreservingString Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) Parameters reader Utf8JsonReader The JSON reader typeToConvert Type The type to convert to options JsonSerializerOptions The serializer options Returns CasePreservingString The parsed CasePreservingString ReadAsPropertyName(ref Utf8JsonReader, Type, JsonSerializerOptions) Reads a CasePreservingString from JSON as a property name (for dictionary keys). public override CasePreservingString ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) Parameters reader Utf8JsonReader The JSON reader typeToConvert Type The type to convert to options JsonSerializerOptions The serializer options Returns CasePreservingString The parsed CasePreservingString Write(Utf8JsonWriter, CasePreservingString, JsonSerializerOptions) Writes a CasePreservingString to JSON. public override void Write(Utf8JsonWriter writer, CasePreservingString value, JsonSerializerOptions options) Parameters writer Utf8JsonWriter The JSON writer value CasePreservingString The CasePreservingString to write options JsonSerializerOptions The serializer options WriteAsPropertyName(Utf8JsonWriter, CasePreservingString, JsonSerializerOptions) Writes a CasePreservingString to JSON as a property name (for dictionary keys). public override void WriteAsPropertyName(Utf8JsonWriter writer, CasePreservingString value, JsonSerializerOptions options) Parameters writer Utf8JsonWriter The JSON writer value CasePreservingString The CasePreservingString to write options JsonSerializerOptions The serializer options"
  },
  "api/Blackwood.Converter2D-1.html": {
    "href": "api/Blackwood.Converter2D-1.html",
    "title": "Class Converter2D<T> | Blackwood.System.Text.Json",
    "summary": "Class Converter2D<T> Namespace Blackwood Assembly Blackwood.System.Text.Json.dll Custom JSON converter for Point serialization and deserialization. public class Converter2D<T> : JsonConverter<T> Type Parameters T Inheritance object JsonConverter JsonConverter<T> Converter2D<T> Inherited Members JsonConverter<T>.CanConvert(Type) JsonConverter<T>.ReadAsPropertyName(ref Utf8JsonReader, Type, JsonSerializerOptions) JsonConverter<T>.WriteAsPropertyName(Utf8JsonWriter, T, JsonSerializerOptions) JsonConverter<T>.HandleNull JsonConverter<T>.Type Methods Read(ref Utf8JsonReader, Type, JsonSerializerOptions) Reads a Point from JSON. public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) Parameters reader Utf8JsonReader The JSON reader typeToConvert Type The type to convert to options JsonSerializerOptions The serializer options Returns T The parsed Point Write(Utf8JsonWriter, T, JsonSerializerOptions) Writes a Point to JSON. public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options) Parameters writer Utf8JsonWriter The JSON writer value T The Point to write options JsonSerializerOptions The serializer options"
  },
  "api/Blackwood.IPAddressConverter.html": {
    "href": "api/Blackwood.IPAddressConverter.html",
    "title": "Class IPAddressConverter | Blackwood.System.Text.Json",
    "summary": "Class IPAddressConverter Namespace Blackwood Assembly Blackwood.System.Text.Json.dll Custom JSON converter for IPAddress serialization and deserialization. public class IPAddressConverter : JsonConverter<IPAddress> Inheritance object JsonConverter JsonConverter<IPAddress> IPAddressConverter Inherited Members JsonConverter<IPAddress>.CanConvert(Type) JsonConverter<IPAddress>.ReadAsPropertyName(ref Utf8JsonReader, Type, JsonSerializerOptions) JsonConverter<IPAddress>.WriteAsPropertyName(Utf8JsonWriter, IPAddress, JsonSerializerOptions) JsonConverter<IPAddress>.HandleNull JsonConverter<IPAddress>.Type Methods Read(ref Utf8JsonReader, Type, JsonSerializerOptions) Reads an IPAddress from JSON. public override IPAddress Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) Parameters reader Utf8JsonReader The JSON reader typeToConvert Type The type to convert to options JsonSerializerOptions The serializer options Returns IPAddress The parsed IPAddress Write(Utf8JsonWriter, IPAddress, JsonSerializerOptions) Writes an IPAddress to JSON. public override void Write(Utf8JsonWriter writer, IPAddress value, JsonSerializerOptions options) Parameters writer Utf8JsonWriter The JSON writer value IPAddress The IPAddress to write options JsonSerializerOptions The serializer options"
  },
  "api/Blackwood.JSONConvert.html": {
    "href": "api/Blackwood.JSONConvert.html",
    "title": "Class JSONConvert | Blackwood.System.Text.Json",
    "summary": "Class JSONConvert Namespace Blackwood Assembly Blackwood.System.Text.Json.dll These are helpers to convert to .Net types public static class JSONConvert Inheritance object JSONConvert Methods ConvertToType(object?, Type) Converts a value to the specified property type. public static object? ConvertToType(object? value, Type targetType) Parameters value object The value to convert. targetType Type The target property type. Returns object The converted value. ToBool(object) Converts an object to a boolean. public static bool ToBool(object o) Parameters o object The object to convert Returns bool The boolean value of the object ToFloat(object) Converts an object to a float public static float ToFloat(object o) Parameters o object The object to convert Returns float The float value of the object ToInt(object) Converts an object to an integer. public static int ToInt(object o) Parameters o object The object to convert Returns int The integer value of the object TryParseColor(string) Converts a string to a Color. Supports named colors, hex codes (#RRGGBB or #AARRGGBB), or returns null for invalid strings. public static Color? TryParseColor(string s) Parameters s string The string representation of the color Returns Color? The Color object corresponding to the string, or null if invalid"
  },
  "api/Blackwood.JSONDeserializer.html": {
    "href": "api/Blackwood.JSONDeserializer.html",
    "title": "Class JSONDeserializer | Blackwood.System.Text.Json",
    "summary": "Class JSONDeserializer Namespace Blackwood Assembly Blackwood.System.Text.Json.dll A custom JSON deserializer extending the standard System.Text.Json functionality to better handle common JSON patterns and provide more flexible type conversion. public class JSONDeserializer : JsonConverter<object> Inheritance object JsonConverter JsonConverter<object> JSONDeserializer Inherited Members JsonConverter<object>.CanConvert(Type) JsonConverter<object>.ReadAsPropertyName(ref Utf8JsonReader, Type, JsonSerializerOptions) JsonConverter<object>.WriteAsPropertyName(Utf8JsonWriter, object, JsonSerializerOptions) JsonConverter<object>.HandleNull JsonConverter<object>.Type Remarks This JSON converter supports Case-insensitive property name matching Support for JSON comments and trailing commas Automatic type inference for numbers (int, long, double) Special handling for boolean strings (“True”/“False”) Flexible object conversion from JsonElement to native .NET types Fields JSONOptions Pre-configured JSON serializer options optimized for flexible JSON parsing. public static readonly JsonSerializerOptions JSONOptions Field Value JsonSerializerOptions Remarks These options support Skips JSON comments during parsing Allows trailing commas in JSON objects and arrays Case-insensitive property name matching Pretty-prints output with indentation Ignores default values when writing JSON Uses the custom JSONDeserializer for improved type conversion Methods ConvertValueToSerializableForm(object?) Serializes a property value to a JSON-compatible format. public static object? ConvertValueToSerializableForm(object? value) Parameters value object The property value to serialize Returns object A JSON-compatible representation of the value DeserializeProperties(object, Dictionary<CasePreservingString, object>, Type) Deserializes properties from a JSON element to an object. public static void DeserializeProperties(object obj, Dictionary<CasePreservingString, object> properties, Type attributeType) Parameters obj object The object to deserialize properties to properties Dictionary<CasePreservingString, object> The properties to deserialize attributeType Type The attribute type to use for deserialization Deserialize<T>(Stream) Asynchronously deserializes JSON from a stream into a strongly-typed object. This method is optimized for reading large JSON documents from streams without loading the entire content into memory at once. public static ValueTask<T?> Deserialize<T>(Stream stream) Parameters stream Stream The stream containing JSON data to deserialize Returns ValueTask<T> A ValueTask containing the deserialized object of type T Type Parameters T The target type to deserialize to Exceptions JsonException Thrown when the JSON stream is malformed ArgumentNullException Thrown when the stream is null Deserialize<T>(string) Deserializes a JSON string into a strongly-typed object. This method provides JSON parsing with support for comments, trailing commas, and case-insensitive property matching. public static T? Deserialize<T>(string jsonString) Parameters jsonString string The JSON string to deserialize Returns T The deserialized object of type T, or default(T) if the input is null/empty Type Parameters T The target type to deserialize to Exceptions JsonException Thrown when the JSON string is malformed JsonToNormal(JsonElement) Converts a JsonElement to its most appropriate .NET object representation. This method provides intelligent type conversion based on the JSON value kind, including special handling for boolean strings and automatic type inference. public static object? JsonToNormal(JsonElement item) Parameters item JsonElement The JsonElement to convert Returns object The converted .NET object with the most appropriate type, or null for unsupported types Examples var json = \"\\\"true\\\"\"; var element = JsonDocument.Parse(json).RootElement; var result = JSONDeserializer.JsonToNormal(element); // Returns bool true Remarks Supported conversions: JsonValueKind.String: Converts to string, with special handling for “true”/“false” strings JsonValueKind.Number: Converts to double JsonValueKind.True/False: Converts to boolean JsonValueKind.Array: Converts to object[] using ToArray method JsonValueKind.Object: Converts to Dictionary<string, object> using ToDict method JsonValueKind.Null: Returns null Unsupported types: Returns null Read(ref Utf8JsonReader, Type, JsonSerializerOptions) Custom JSON converter that reads JSON tokens and converts them to appropriate .NET types. This method extends type inference and conversion capabilities beyond the standard System.Text.Json behavior. public override object? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) Parameters reader Utf8JsonReader The JSON reader positioned at the token to convert typeToConvert Type The target type for conversion (typically object) options JsonSerializerOptions The JSON serializer options Returns object The converted .NET object with the most appropriate type SerializeProperties(object, Type) Serializes custom properties marked with give attribute. public static Dictionary<CasePreservingString, object> SerializeProperties(object from, Type AttributeType) Parameters from object AttributeType Type Returns Dictionary<CasePreservingString, object> A dictionary of serialized property values ToArray(JsonElement) Converts a JsonElement representing a JSON array to an object array. public static object[] ToArray(JsonElement v) Parameters v JsonElement The JsonElement representing a JSON array to convert Returns object[] An object array containing all converted elements Examples var json = \"[1, \\\"hello\\\", true, [2, 3]]\"; var element = JsonDocument.Parse(json).RootElement; var result = JSONDeserializer.ToArray(element); // result[0] is double 1.0, result[1] is string \"hello\", result[2] is bool true, result[3] is object[] [2.0, 3.0] Remarks This method processes all elements in the JSON array and converts each element to its appropriate .NET type. ToDict(Dictionary<string, object>) Converts a dictionary containing JsonElement values to a dictionary with native .NET objects. public static Dictionary<CasePreservingString, object> ToDict(Dictionary<string, object> jsonDictionary) Parameters jsonDictionary Dictionary<string, object> The dictionary containing JsonElement values to convert Returns Dictionary<CasePreservingString, object> A new dictionary with all values converted to native .NET objects Examples var dict = new Dictionary<string, object>(); dict[\"name\"] = JsonDocument.Parse(\"\\\"John\\\"\").RootElement; dict[\"age\"] = JsonDocument.Parse(\"30\").RootElement; var result = JSONDeserializer.ToDict(dict); // result[\"name\"] is string \"John\", result[\"age\"] is double 30.0 Remarks This method recursively processes all values in the dictionary, converting JsonElements to their appropriate .NET types. ToDict(JsonElement) Converts a JsonElement representing a JSON object to a Dictionary<string, object>. public static Dictionary<CasePreservingString, object> ToDict(JsonElement jsonDictionary) Parameters jsonDictionary JsonElement The JsonElement representing a JSON object to convert Returns Dictionary<CasePreservingString, object> A dictionary containing all properties with converted .NET object values Examples var json = \"{\\\"name\\\": \\\"John\\\", \\\"age\\\": 30, \\\"active\\\": true}\"; var element = JsonDocument.Parse(json).RootElement; var result = JSONDeserializer.ToDict(element); // result[\"name\"] is string \"John\", result[\"age\"] is double 30.0, result[\"active\"] is bool true Remarks This method processes all properties in the JSON object and converts their values to appropriate .NET types. Write(Utf8JsonWriter, object, JsonSerializerOptions) Writes a .NET object to JSON format. This method is primarily used for serialization scenarios, though the main focus of this class is on deserialization with improved parsing capabilities. public override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options) Parameters writer Utf8JsonWriter The JSON writer to write the serialized data to value object The .NET object to serialize to JSON options JsonSerializerOptions The JSON serializer options to use"
  },
  "api/Blackwood.PointConverter.html": {
    "href": "api/Blackwood.PointConverter.html",
    "title": "Class PointConverter | Blackwood.System.Text.Json",
    "summary": "Class PointConverter Namespace Blackwood Assembly Blackwood.System.Text.Json.dll Custom JSON converter for Point serialization and deserialization. public class PointConverter : JsonConverter<Point> Inheritance object JsonConverter JsonConverter<Point> PointConverter Inherited Members JsonConverter<Point>.CanConvert(Type) JsonConverter<Point>.ReadAsPropertyName(ref Utf8JsonReader, Type, JsonSerializerOptions) JsonConverter<Point>.WriteAsPropertyName(Utf8JsonWriter, Point, JsonSerializerOptions) JsonConverter<Point>.HandleNull JsonConverter<Point>.Type Methods Read(ref Utf8JsonReader, Type, JsonSerializerOptions) Reads a Point from JSON. public override Point Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) Parameters reader Utf8JsonReader The JSON reader typeToConvert Type The type to convert to options JsonSerializerOptions The serializer options Returns Point The parsed Point Write(Utf8JsonWriter, Point, JsonSerializerOptions) Writes a Point to JSON. public override void Write(Utf8JsonWriter writer, Point value, JsonSerializerOptions options) Parameters writer Utf8JsonWriter The JSON writer value Point The Point to write options JsonSerializerOptions The serializer options"
  },
  "api/Blackwood.html": {
    "href": "api/Blackwood.html",
    "title": "Namespace Blackwood | Blackwood.System.Text.Json",
    "summary": "Namespace Blackwood Classes CasePreservingStringConverter Custom JSON converter for CasePreservingString serialization and deserialization. Supports both regular serialization and dictionary key serialization. Converter2D<T> Custom JSON converter for Point serialization and deserialization. IPAddressConverter Custom JSON converter for IPAddress serialization and deserialization. JSONConvert These are helpers to convert to .Net types JSONDeserializer A custom JSON deserializer extending the standard System.Text.Json functionality to better handle common JSON patterns and provide more flexible type conversion. Structs CasePreservingString This represents a string that preserves its original case for display purposes but allows for case-insensitive comparisons. It provides methods to convert a string to this struct, compare two instances in a case-insensitive manner, and generate a hash code based on the uppercase version of the string."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation | Blackwood.System.Text.Json",
    "summary": "API Documentation This section contains the API reference documentation for the Blackwood.System.Text.Json library. Namespaces Blackwood - Main namespace containing utility classes Classes JSONConvert - Customer conversion utilities JSONDeserializer - Enhanced deserialization with flexible type handling Getting Started For detailed information about each class and its methods, click on the links above or use the navigation menu."
  },
  "articles/examples.html": {
    "href": "articles/examples.html",
    "title": "Examples and Recommendations | Blackwood.System.Text.Json",
    "summary": "Examples and Recommendations This article provides examples using Blackwood.System.Text.Json. Table of Contents Basic Usage Patterns Working with Complex JSON Type Conversion Examples Recommendations Basic Usage Patterns Simple Object Deserialization Below is a simple example demonstrating deserialization with automatic type conversion to match the correct property types of your C# object. using Blackwood; // Basic user data with mixed data types (strings and actual types) var userJson = \"\"\" { \"id\": \"12345\", // String that will be converted to int \"name\": \"John Doe\", // Regular string \"email\": \"john@example.com\", \"isActive\": \"true\", // String that will be converted to bool \"lastLogin\": \"2024-01-15T10:30:00Z\" // ISO 8601 date string } \"\"\"; // Model class with strongly-typed properties public class User { public int Id { get; set; } // Will receive converted int from \"12345\" public string Name { get; set; } // Direct string mapping public string Email { get; set; } // Direct string mapping public bool IsActive { get; set; } // Will receive converted bool from \"true\" public DateTime LastLogin { get; set; } // Will parse ISO 8601 date string } // Deserialize with automatic type conversion var user = JSONDeserializer.Deserialize<User>(userJson); Working with Arrays Here is an example showing how deserialization works with an array. // JSON array with multiple objects containing string values that need conversion var productsJson = \"\"\" [ { \"id\": \"1\", // String to int conversion \"name\": \"Laptop\", // Direct string \"price\": \"999.99\", // String to decimal conversion \"inStock\": \"true\" // String to bool conversion }, { \"id\": \"2\", // String to int conversion \"name\": \"Mouse\", // Direct string \"price\": \"29.99\", // String to decimal conversion \"inStock\": \"false\" // String to bool conversion } ] \"\"\"; // Product model class public class Product { public int Id { get; set; } // Will receive converted int values public string Name { get; set; } // Direct string mapping public decimal Price { get; set; } // Will receive converted decimal values public bool InStock { get; set; } // Will receive converted bool values } // Deserialize array of products with automatic type conversion var products = JSONDeserializer.Deserialize<Product[]>(productsJson); Working with Complex JSON Now lets look at more complex structures, such as deeply nested objects, arrays, and collections. Nested Objects and Collections Below is an example featuring a deeply nested object structure that includes collections. // Complex nested JSON with multiple levels and mixed data types var orderJson = \"\"\" { \"orderId\": \"ORD-001\", // Direct string \"customer\": { // Nested object \"id\": \"123\", // String to int conversion \"name\": \"Alice Smith\", \"email\": \"alice@example.com\" }, \"items\": [ // Array of nested objects { \"productId\": \"P001\", \"quantity\": \"2\", // String to int conversion \"unitPrice\": \"19.99\" // String to decimal conversion }, { \"productId\": \"P002\", \"quantity\": \"1\", // String to int conversion \"unitPrice\": \"49.99\" // String to decimal conversion } ], \"shipping\": { // Another nested object \"address\": \"123 Main St\", \"city\": \"New York\", \"zipCode\": \"10001\" // String (could be converted to int if needed) }, \"total\": \"89.97\" // String to decimal conversion } \"\"\"; // Main order class with nested object properties public class Order { public string OrderId { get; set; } // Direct string mapping public Customer Customer { get; set; } // Nested object public List<OrderItem> Items { get; set; } // Collection of nested objects public ShippingInfo Shipping { get; set; } // Nested object public decimal Total { get; set; } // Will receive converted decimal } // Customer nested class public class Customer { public int Id { get; set; } // Will receive converted int public string Name { get; set; } // Direct string mapping public string Email { get; set; } // Direct string mapping } // Order item nested class public class OrderItem { public string ProductId { get; set; } // Direct string mapping public int Quantity { get; set; } // Will receive converted int public decimal UnitPrice { get; set; } // Will receive converted decimal } // Shipping info nested class public class ShippingInfo { public string Address { get; set; } // Direct string mapping public string City { get; set; } // Direct string mapping public string ZipCode { get; set; } // Direct string mapping } // Deserialize complex nested structure with automatic type conversion var order = JSONDeserializer.Deserialize<Order>(orderJson); Dynamic JSON with Unknown Structure When you are working with JSON data whose structure is not known – or fully known – at compile time you can deserialize them into an object type. For instance processing configuration files or loosely-typed APIs. This will deserialize into a dynamic object: // JSON with unknown structure - perfect for configuration files var dynamicJson = \"\"\" { \"config\": { \"database\": { \"host\": \"localhost\", \"port\": \"5432\", // String that can be converted to int \"name\": \"myapp\" }, \"features\": { \"enableLogging\": \"true\", // String that can be converted to bool \"maxConnections\": \"100\", // String that can be converted to int \"timeout\": \"30\" // String that can be converted to int } }, \"metadata\": { \"version\": \"1.0.0\", \"environment\": \"production\" } } \"\"\"; // Deserialize to dynamic object when structure is unknown at compile time var config = JSONDeserializer.Deserialize<object>(dynamicJson); // Access nested properties with automatic type conversion var host = config.config.database.host; // \"localhost\" (string) var port = config.config.database.port; // 5432 (converted from \"5432\" string to int) var enableLogging = config.config.features.enableLogging; // true (converted from \"true\" string to bool) Type Conversion Examples The JSONConvert class provides tools to aid converting from JSON values (often strings) to the expected .NET types in your classes or variables. // Convert various string types to their .NET equivalents var intValue = JSONConvert.ToInt(\"123\"); // 123 (string to int) var floatValue = JSONConvert.ToFloat(\"45.67\"); // 45.67f (string to float) var boolValue = JSONConvert.ToBool(\"true\"); // true (string to bool) var boolValue2 = JSONConvert.ToBool(\"True\"); // true (case insensitive conversion) // Parse colors from various string formats var color1 = JSONConvert.TryParseColor(\"#FF0000\"); // Red (hex format) var color2 = JSONConvert.TryParseColor(\"blue\"); // Blue (named color) var color3 = JSONConvert.TryParseColor(\"#00FF0080\"); // Green with alpha (hex with alpha) Recommendations Use strongly-typed models when possible Always handle potential null values Wrap deserialization in try-catch blocks The library converts types, but validate your assumptions 1. Use Strongly-Typed Models When Possible With strongly-typeed models, the deserialization converter has better information how to deserialize the data. // Good: Strongly-typed model provides compile-time safety and IntelliSense public class User { public int Id { get; set; } // Strongly-typed property public string Name { get; set; } // Strongly-typed property public string Email { get; set; } // Strongly-typed property } // Deserialize to strongly-typed object var user = JSONDeserializer.Deserialize<User>(json); // Avoid: Dynamic objects when structure is known (loses type safety) var user = JSONDeserializer.Deserialize<object>(json); 2. Use Appropriate Data Types // Good: Use appropriate types for the data to enable proper operations public class Product { public int Id { get; set; } // Integer for IDs (enables numeric operations) public decimal Price { get; set; } // Decimal for money (prevents floating-point errors) public bool InStock { get; set; } // Boolean for flags (enables logical operations) public DateTime CreatedAt { get; set; } // DateTime for dates (enables date operations) } // Avoid: Using strings for everything (loses type safety and functionality) public class BadProduct { public string Id { get; set; } // Should be int (can't do math operations) public string Price { get; set; } // Should be decimal (can't do calculations) public string InStock { get; set; } // Should be bool (can't use in conditions) } 3. Handle Null Values Gracefully It's important to handle null values gracefully during deserialization. JSON data might have missing fields, or incoming data could be incomplete or malformed. If you don't check for nulls, you may run into NullReferenceExceptions or application errors. When handling null values in a class, use nullable types and provide sensible default property values to avoid runtime errors: // User class with null-safe defaults to prevent null reference exceptions public class SafeUser { public int Id { get; set; } // Required field public string Name { get; set; } = string.Empty; // Default to empty string public string Email { get; set; } = string.Empty; // Default to empty string public DateTime? LastLogin { get; set; } // Nullable for optional field public List<string> Tags { get; set; } = new List<string>(); // Initialize empty list } The following section demonstrates how to safely invoke the deserializer and handle cases where the resulting object or its properties might be null, preventing runtime errors and enabling robust error handling in your application. // Example: Graceful null handling after deserialization var user = JSONDeserializer.Deserialize<User>(json); if (user == null) { // Handle null object appropriately Console.WriteLine(\"Deserialization failed: user is null.\"); return; } // Check for required properties that may be null or missing if (string.IsNullOrEmpty(user.Email)) { Console.WriteLine(\"No email address provided; using default.\"); user.Email = \"unknown@example.com\"; } // Alternative: Use null-conditional and null-coalescing operators string displayName = user?.Name ?? \"Guest\"; DateTime lastLogin = user?.LastLogin ?? DateTime.MinValue; Next Steps API Reference - Explore the complete API Getting Started - Review the basics if needed"
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started with Blackwood.System.Text.Json | Blackwood.System.Text.Json",
    "summary": "Getting Started with Blackwood.System.Text.Json This guide will help you get up and running with Blackwood.System.Text.Json quickly and easily. Prerequisites .NET 8.0 or later - The library targets .NET 8.0+ Visual Studio 2022 (Windows) or VS Code with C# extension (cross-platform) Installation Package Manager Console Install-Package Blackwood.System.Text.Json .NET CLI dotnet add package Blackwood.System.Text.Json PackageReference Add the following to your .csproj file: <PackageReference Include=\"Blackwood.System.Text.Json\" Version=\"2.0.0\" /> Quick Start 1. Add the Using Statement using Blackwood; 2. Basic Deserialization The simplest way to use Blackwood.System.Text.Json is with the JSONDeserializer.Deserialize<T>() method: using Blackwood; // JSON with some common issues that standard System.Text.Json would struggle with var json = \"\"\" { \"name\": \"John Doe\", \"age\": \"30\", // String number - automatically converted to int \"isActive\": \"True\", // String boolean - automatically converted to bool \"salary\": 75000.50, // Regular number \"department\": \"IT\" // Regular string } \"\"\"; // Define your model class to match the JSON structure public class Employee { public string Name { get; set; } // Maps to \"name\" property public int Age { get; set; } // Maps to \"age\" (string converted to int) public bool IsActive { get; set; } // Maps to \"isActive\" (string converted to bool) public decimal Salary { get; set; } // Maps to \"salary\" property public string Department { get; set; } // Maps to \"department\" property } // Deserialize JSON to the Employee object (automatic type conversion) var employee = JSONDeserializer.Deserialize<Employee>(json); // Display the results to verify type conversion worked Console.WriteLine($\"Name: {employee.Name}\"); Console.WriteLine($\"Age: {employee.Age} (type: {employee.Age.GetType().Name})\"); Console.WriteLine($\"Active: {employee.IsActive} (type: {employee.IsActive.GetType().Name})\"); Key Features in Action Case-Insensitive Property Matching // JSON with inconsistent property name casing var json = \"\"\" { \"FirstName\": \"John\", \"lastname\": \"Doe\", // Different casing from LastName \"EMAIL\": \"john@example.com\" // Different casing from Email } \"\"\"; // Model class with standard PascalCase property names public class Person { public string FirstName { get; set; } // Matches \"FirstName\" public string LastName { get; set; } // Matches \"lastname\" (case-insensitive) public string Email { get; set; } // Matches \"EMAIL\" (case-insensitive) } // Deserialize to the Person object. // This works despite case mismatches - library handles case-insensitive matching var person = JSONDeserializer.Deserialize<Person>(json); JSON with Comments and Trailing Commas // JSON with comments and trailing comma (normally invalid JSON) var jsonWithComments = \"\"\" { // This is a comment - normally not allowed in JSON \"name\": \"John\", \"age\": 30, \"city\": \"New York\", // Trailing comma - normally causes parsing errors! } \"\"\"; // Deserialize JSON with comments and trailing commas (library handles both) var person = JSONDeserializer.Deserialize<Person>(jsonWithComments); Flexible Type Conversion Sometimes you will wish to work with JSON that might use different types from the strict set used in .Net. The tools can automatically convert between these. // JSON with string values that need type conversion var json = \"\"\" { \"id\": \"123\", // String to int conversion \"price\": \"29.99\", // String to decimal conversion \"inStock\": \"true\", // String to bool conversion \"tags\": [\"new\", \"sale\"] // Array handling (no conversion needed) } \"\"\"; // Model class with strongly-typed properties public class Product { public int Id { get; set; } // Will receive converted int value public decimal Price { get; set; } // Will receive converted decimal value public bool InStock { get; set; } // Will receive converted bool value public string[] Tags { get; set; } // Will receive string array } // Deserialize with automatic type conversion var product = JSONDeserializer.Deserialize<Product>(json); Using Pre-configured Options The library provides pre-configured JsonSerializerOptions optimized for common scenarios: // Use the pre-configured options (includes all enhanced features) var options = JSONDeserializer.JSONOptions; // Or create custom options based on the pre-configured ones var customOptions = new JsonSerializerOptions(JSONDeserializer.JSONOptions) { WriteIndented = true, // Pretty-print JSON PropertyNamingPolicy = JsonNamingPolicy.CamelCase // Convert property names to camelCase }; Next Steps API Reference - Explore the full API for detailed method documentation Examples - for common patterns Troubleshooting Q: My properties aren't being populated A: Check that your JSON property names match your C# property names (case-insensitive matching is enabled by default). Q: I'm getting type conversion errors A: The library handles most common conversions automatically. For complex types, consider using custom converters."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Introduction to Blackwood.System.Text.Json | Blackwood.System.Text.Json",
    "summary": "Introduction to Blackwood.System.Text.Json Blackwood.System.Text.Json is a library to extend the standard System.Text.Json functionality in .NET. It provides added support for JSON parsing, flexible type conversion, and improved handling of common JSON patterns. JSON comment support - The defaults here allows comments and documentation. Trailing comma tolerance - The defaults here allow trailing commas. Type conversion - Smart conversion of numbers, booleans, and strings. For instance “True”/“False” (yes/no) strings can be converted to booleans Getting Started The library is designed to be a drop-in enhancement to System.Text.Json. You can start using it immediately with minimal code changes: using Blackwood; // Simple deserialization with enhanced features var json = \"\"\" { \"name\": \"John Doe\", \"age\": \"30\", // String number - automatically converted \"isActive\": \"True\", // String boolean - automatically converted \"settings\": { \"theme\": \"dark\", \"notifications\": true } } \"\"\"; // Deserialize JSON with automatic type conversion // The library handles string-to-number and string-to-boolean conversion var result = JSONDeserializer.Deserialize<Person>(json); Core Components JSONDeserializer – The main class providing enhanced JSON deserialization capabilities. JSONConvert – A utility class for type conversion operations: parsing colors, booleans, etc. Next Steps Getting Started Guide - Installation and basic setup API Reference - Detailed API documentation Examples - Real-world usage patterns"
  },
  "building-docs.html": {
    "href": "building-docs.html",
    "title": "Blackwood.System.Text.Json Documentation | Blackwood.System.Text.Json",
    "summary": "Blackwood.System.Text.Json Documentation This directory contains the documentation project for the Blackwood.System.Text.Json library. Prerequisites .NET 8.0 SDK or later DocFX (will be installed automatically by the build scripts) Building the Documentation Option 1: Using Visual Studio To build the documentation using Visual Studio: Open the Blackwood.System.Text.Json.sln solution file in Visual Studio. In the Solution Explorer, locate the Documentation project. Right-click the Documentation project and select Build. Upon successful build, the documentation output will be generated in the ../docs directory. Option 2: Using the Batch Script (Windows) To build and view the documentation locally: Navigate to the Documentation folder Run the build script: .\\build-docs.bat Option 3: Using PowerShell Script (Windows) To build and view the documentation locally: Navigate to the Documentation folder Run the build script: .\\build-docs.ps1 Option 4: Manual Build Install DocFX globally: dotnet tool install -g docfx Generate the documentation: docfx docfx.json Output The generated documentation will be available in the ../docs directory. Open ../docs/index.html in your web browser to view the documentation. When Visual Studio builds the docs, it will also start a local webserver to allow browsing the documents at http://localhost:8080 The documentation, when browsed from a local filesystem, may require tweaking the browser. Firefox Go to about:config and set: security.fileuri.strict_origin_policy to false privacy.file_unique_origin to false Chrome Use a local web server extension like “Web Server for Chrome” or serve the files through a development server. Brave When view the local documentation files with the Brave browser, additional steps are needed. You will have to launch Brave from the command line with specific flags to relax its restrictions. This will not full work, but it allows reading. Open your command prompt or terminal. Launch Brave with the following flags, replacing <path-to-your-index.html> with the full path to your documentation file: macOS: open -n \"/Applications/Brave Browser.app\" --args --user-data-dir=\"$HOME/brave-dev-data\" --disable-web-security \"<path-to-your-index.html>\" Windows: \"C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe\" --user-data-dir=C:\\brave-dev-data --disable-web-security \"<path-to-your-index.html>\" The following flags are important: --allow-file-access-from-files enables local file access for the browser. --disable-web-security disables certain browser security measures (only use this for trusted, local documentation). Make sure to specify the exact path to your documentation index file. Project Structure docfx.json - DocFX configuration file index.md - Main documentation page api/ - API documentation files articles/ - Conceptual documentation template/ - Custom DocFX template files contributing/ - Contributing guidelines Configuration The docfx.json file contains the configuration for: Source code metadata extraction from ../src Content files (markdown, API docs) Output destination (../docs) Template and styling options docfx is fussy, brittle, and its docfx.json documentation is often not helpful for either setting up the project or figuring out why its not working. (Sure there is documentation, but its thin on substance, little on what the actual settings do, or how to accomplish anything.) Updating Documentation Modify the markdown files in this directory Update API documentation by adding XML documentation comments to the source code Run the build script to regenerate the documentation The updated documentation will be available in ../docs"
  },
  "contributing/CONTRIBUTING.html": {
    "href": "contributing/CONTRIBUTING.html",
    "title": "Contributing | Blackwood.System.Text.Json",
    "summary": "Contributing Thanks for being interested in contributing! We're so glad you want to help! We want contributing to be fun, enjoyable, and educational for all. We love receiving contributions from our community, all contributions are welcome. There are many ways to contribute. You can also help us by: Answering questions people have have in the forums Helping us build and design our website Cleaning up our existing documentation, polishing it, fixing our spelling or grammar mistakes, and so on Create new documentation Create an example of some changes / fixes/ hacks Reviewing submissions Contributing bits that can be incorporated into this or related projects. Below you will find tips on how to get the most out of your contributing experience, including GitHub management tips, setup instructions for docs and code contributions, and more. Not sure how to start contributing? If you are worried or don't know where to start, you can reach out with questions to GitHub Discussions is directly integrated with the repository. You can use this to ask for help or share ideas related to improving the documentation or deploying it. How to start contributing and our code of conduct Below you'll find guides on our community, code of conduct, and how to get started contributing: Code of Conduct: Read about what we expect from everyone participating to make it the most friendly and welcoming community. Style Guide: The art of contributing, a.k.a. the detailed requirements that will make it more likely your contribution is accepted with minimal changes. By participating in this project, you agree to abide by our Code of Conduct. We expect all contributors to follow the Code of Conduct and to treat fellow humans with respect. Important Resources The important documents and links are on the front page of the wiki. Improving Documentation If you have a suggestion for the documentation, we ask that you take a stab at making the changes to the documentation. Simple changes can often be made without a sophisticated pull release. For large fixes, please build and test the documentation before submitting the pull-request to be sure you haven't accidentally introduced any layout or formatting issues. Whitespace Cleanup Don't mix code or documentation changes with whitespace cleanup! If you are fixing whitespace, include those changes separately from your code changes. If your request is unreadable due to whitespace changes, it will be rejected. Please submit whitespace cleanups in a separate pull request. Reorganizing Filesystem / directory tree Don't mix rearranging the location and names of files with code or documentation changes! If you are rearranging the file system, please include those changes separately from your code changes. Please submit file system changes in a separate pull request. Pull Request Process Please see the pull requests page for the process of submitting your changes to the prooject and incorporating feedback. are happy with your changes first! Credits: This page was adapted from an EmbeddedArtistry template"
  },
  "contributing/code_of_conduct.html": {
    "href": "contributing/code_of_conduct.html",
    "title": "Contributor Covenant Code of Conduct | Blackwood.System.Text.Json",
    "summary": "Contributor Covenant Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at [INSERT CONTACT METHOD]. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact: A violation through a single incident or series of actions. Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact: A serious violation of community standards, including sustained inappropriate behavior. Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence: A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder. For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations."
  },
  "contributing/how-to-file-an-issue.html": {
    "href": "contributing/how-to-file-an-issue.html",
    "title": "Issues and Bug Tracking | Blackwood.System.Text.Json",
    "summary": "Issues and Bug Tracking How to File an Issue The GitHub issue tracker is the preferred channel for bug reports, documentation, feature requests and submitting pull requests. To resolve your issue, please select the appropriate category: Bug Reports Documentation Feature Requests For bug reports, include in your issue: The OS version you are running the software on The language (C#, javascript, go, etc) that you are targeting A reproduction for debugging and taking action Please do not use the issue tracker for personal support requests. The discourse and forums are the better places to request help. Labelling the issues Issue labels are a tool in GitHub that are used to group issues into one or more categories. Labeling issues helps by identifying: good issues for new contributors to work on reported and confirmed bugs feature requests duplicate issues issues that are stalled or blocked the status of an open issue the topic or subject matter of the issue When an issue is created – and later examined – this is a good time to check that its label is sensible, and to add an other labels that are helpful – and to remove labels that do not apply. You can see a list of this project's labels (and their descriptions). Tracking and Helping with Issues If an issue is affecting you, start at the top of this list and complete as many tasks on the list as you can: If there is an issue and you can add more detail, write a comment describing how the problem is affecting you, OR if you can, write up a work-around or improvement for the issue If there is not an issue, write the most complete description of what's happening Offer to help fix the issue (and it is totally expected that you ask for help; open-source maintainers want to help contributors) Deliver a well-crafted, tested PR Credits: this was adapted from the Gatsbj.js project"
  },
  "contributing/pull-requests.html": {
    "href": "contributing/pull-requests.html",
    "title": "Pull Requests | Blackwood.System.Text.Json",
    "summary": "Pull Requests This document describes what you needed to know about the pull request process. A pull request is how you submit your changes to the project. Before you make any changes, please read the contributing page for information regarding contributions to project overall. This will help you in making your changes fit within the project and its style; as well as the steps you must do before creating a pull-request. What is a Pull Request (PR)? As described above, a pull request is how you submit changes to this project. It is a request that the project pull in your changes. Here's how the folks at GitHub define a pull request: Pull requests let you tell others about changes you've pushed to a branch in a repository on GitHub. Once a pull request is opened, you can discuss and review the potential changes with collaborators and add follow-up commits before your changes are merged into the base branch. The pull request allows others to review the changes, test them, and provide feedback – including requests to makes to the changees, so that they better fit into the project. Pull Request Process Once you have completed the changes on your local development environment, tested them, and so fprth, the next steps is to create a pull request. Be sure to check the contributing guide for additional steps and tips to ensure that your changes will fit with the project. When you are ready to generate a pull request, either for preliminary review, or for consideration of merging into the project you must first push your local topic branch back up to GitHub: git push origin newfeature Once you've committed and pushed all of your changes to GitHub, go to the page for your fork on GitHub, select your development branch, and click the pull request button. If you need to make any adjustments to your pull request, just push the updates to your branch. Your pull request will automatically track the changes on your development branch and update. Ensure any install or build dependencies are removed before the end of the layer when doing a build. You may merge the Pull Request in once you have the sign-off of two other developers, or if you do not have permission to do that, you may request the second reviewer to merge it for you. Review Process After a pull request has been sent to the repository, the team and community may suggest modifications to the changes you have submitted. Many pull requests are likely to open for several days, until the core team can approve them in Github. In some cases, multiple people will have the chance to review/comment. Please check your pull request for comments, feedback, and suggested changes: Review the suggested changes using the “View changes” button. Commit the suggestions. Discuss suggestions to ask questions about the suggested changes. Incoprorate the suggestions to your changes Addressing Feedback Once a PR has been submitted, your changes will be reviewed and constructive feedback may be provided. Feedback isn't meant as an attack, but to help make sure the highest-quality workmanship makes it into our project. Changes will be approved once required feedback has been addressed. If a maintainer asks you to “rebase” your PR, they're saying that a lot of files has changed, and that you need to update your fork so it's easier to merge. To update your forked repository, follow these steps: # Fetch upstream master and merge with your repo's master branch git fetch upstream git checkout master git merge upstream/master # If there were any new commits, rebase your development branch git checkout newfeature git rebase master If too much code has changed for git to automatically apply your branches changes to the new master, you will need to manually resolve the merge conflicts yourself. Once your new branch has no conflicts and works correctly, you can override your old branch using this command: git push -f Note that this will overwrite the old branch on the server, so make sure you are happy with your changes first! Additional resources Creating a pull request from GitHub Configuring a remote for a fork Which remote URL should I use? Git Branching and Merging Feature Branching and Workflows Resolving merge conflicts Credits: This page was adapted from an EmbeddedArtistry template and adapted from the Gatsbj.js project"
  },
  "contributing/style-guide.html": {
    "href": "contributing/style-guide.html",
    "title": "Style Guide | Blackwood.System.Text.Json",
    "summary": "Style Guide The .proto files should follow Google's protobuf style guidelines. Documentation style Markdown files The title of the document should use a # (in Markdown). Only a single title (#) should be used. The heading levels should start with ## (in Markdown) and grow in order Links ought to be relative instead of absolute when linking to documents. That is to say, the should not include the full domain. For example /documents/some-reference/ instead of https://randym32.github.io/Blackwood.System.Text.Json/some-reference/"
  },
  "index.html": {
    "href": "index.html",
    "title": "Blackwood.System.Text.Json | Blackwood.System.Text.Json",
    "summary": "Blackwood.System.Text.Json This assembly is collection of utilitites for the System.Text.Json to make JSON serialization and deserialization more flexible. Overview Utility Classes: JSONDeserializer – Enhanced deserialization with flexible type handling. JSONConvert – Customer conversion utilities. View the API Documentation for detailed information about available namespaces, classes, and methods. Getting Started Prerequisites .NET 8.0 or later Visual Studio 2022 or later (Windows), or VS Code with C# extension (cross-platform) Installation Install the package via NuGet: dotnet add package Blackwood.System.Text.Json Or using Package Manager Console: Install-Package Blackwood.System.Text.Json Quick Start using Blackwood; // Example JSON structure var json = \"\"\" { \"name\": \"John Doe\", \"age\": 30, \"isActive\": \"True\" } \"\"\"; // Deserialize the JSON to a Person object. var result = JSONDeserializer.Deserialize<Person>(json); Resources Source Code: GitHub Repository NuGet Package: Blackwood.System.Text.Json Documentation: API Reference Documentation The API documentation is available at https://randym32.github.io/Blackwood.System.Text.Json. For instructions on how to build or modify the documentation, see How to Build the Documentation. Articles For guides and examples, check out our articles: Introduction - Overview of the library's features and capabilities Getting Started - Installation, configuration, and basic usage Examples - Common scenarios, flexible deserialization with type coercion, error handling. Contributing We welcome contributions! Please see our Contributing Guidelines for information on how to contribute to this project. Issues: Report bugs or request features on GitHub Issues Pull Requests: Submit improvements via GitHub Pull Requests Code of Conduct: Please read our Code of Conduct License This project is licensed under the BSD 2-Clause License – see the LICENSE file for details."
  }
}